{"version":3,"sources":["components/FBX.js","components/View.js","App.js","serviceWorker.js","index.js","logo.svg"],"names":["useEffect","React","useMemo","useRef","loadFBX","group","fbxPath","fbxURL","envMap","castShadow","receiveShadow","materialProps","fbxLoader","FBXLoader","setPath","load","fbx","current","scene","children","map","child","remove","color","otherMaterialProps","updateAllMaterials","Array","isArray","object","constructor","name","material","set","Object","entries","propName","value","traverse","mesh","isMesh","add","console","warn","FBXMemo","memo","view3DEnvMap","otherProps","useViewContext","keys","length","props","undefined","_envMap","loadingText","ref","text","textColor","displayName","View","orbitControls","backgroundColor","hoverColor","onClick","log","textureURL","gltfURL","App","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message","module","exports"],"mappings":"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","file":"static/js/main.dc23b8db.chunk.js","sourcesContent":["// FBX.tsx\nimport * as React from \"react\";\nimport * as THREE from \"three\";\nimport { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader\";\nimport PropTypes from \"prop-types\";\nimport exact from \"prop-types-exact\";\nimport {\n  Label,\n  Group,\n  GroupProps,\n  GroupPropTypes,\n  useViewContext,\n} from \"@standard/view\";\n\nconst { useEffect, useMemo, useRef, memo } = React;\n\ninterface FBXProps extends GroupProps {\n  fbxPath?: string;\n  fbxURL: string;\n}\n\nfunction updateAllMaterials(\n  color: string,\n  children: any,\n  materialProps: any\n): void {\n  if (children == null) {\n    return;\n  }\n\n  const _children = Array.isArray(children) ? children : [children];\n\n  _children.map(object => {\n    // Recurse into Groups\n    if (object.constructor.name === \"Group\" && object.children) {\n      updateAllMaterials(color, object.children, materialProps);\n    }\n\n    // @ts-ignore:TS2339 material does not exist on Object3D\n    if (object.material) {\n      if (color) {\n        // @ts-ignore:TS2339 material does not exist on Object3D\n        object.material.color.set(color);\n      }\n      Object.entries(materialProps).map(([propName, value]) => {\n        /* eslint-disable no-param-reassign */\n        // @ts-ignore:TS2339 material does not exist on Object3D\n        object.material[propName] = value;\n        /* eslint-enable no-param-reassign */\n        return null;\n      });\n    }\n\n    return null;\n  });\n}\n\ninterface LoadFBXProps {\n  group: React.MutableRefObject<any>;\n  fbxPath: string;\n  fbxURL: string;\n  envMap: THREE.Texture;\n  castShadow: boolean;\n  receiveShadow: boolean;\n  materialProps: any;\n}\n\nfunction loadFBX({\n  group,\n  fbxPath,\n  fbxURL,\n  envMap,\n  castShadow,\n  receiveShadow,\n  materialProps,\n}: LoadFBXProps): void {\n  // No FBX\n  if (fbxURL == null) {\n    /* eslint-disable no-console */\n    console.warn(\"[FBX] No fbxURL\");\n    /* eslint-enable no-console */\n    return;\n  }\n\n  // FBX\n  const fbxLoader = new FBXLoader();\n  fbxLoader.setPath(fbxPath);\n  fbxLoader.load(fbxURL, fbx => {\n    if (group.current && fbx.scene && fbx.scene.children) {\n      // Remove Loading Label or Previous OBJ\n      if (group.current.children) {\n        group.current.children.map(child => group.current.remove(child));\n      }\n\n      // Material Props\n      if (materialProps) {\n        const { color, ...otherMaterialProps } = materialProps;\n        updateAllMaterials(color, fbx.scene.children, otherMaterialProps);\n      }\n\n      // Env Map + Shadows\n      fbx.scene.traverse(mesh => {\n        /* eslint-disable no-param-reassign */\n        // @ts-ignore\n        if (mesh.isMesh) {\n          if (envMap) {\n            // @ts-ignore\n            mesh.material.envMap = envMap;\n          }\n          mesh.castShadow = castShadow;\n          mesh.receiveShadow = receiveShadow;\n        }\n        /* eslint-enable no-param-reassign */\n      });\n\n      // Add FBX\n      group.current.add(fbx.scene);\n    }\n  });\n}\n\nconst FBX: React.FunctionComponent<FBXProps> = function FBX({\n  fbxPath = \"\",\n  fbxURL,\n  view3DEnvMap = false,\n  castShadow = false,\n  receiveShadow = false,\n  ...otherProps\n}) {\n  const group = useRef();\n  const { envMap } = useViewContext();\n\n  // Material Props\n  const materialProps = useMemo(\n    function updateMaterialProps() {\n      // No Material Props\n      if (!otherProps || Object.keys(otherProps).length === 0) {\n        return undefined;\n      }\n\n      // Acceptable Material Props\n      const materialPropsKeys = [\n        \"color\",\n        \"wireframe\",\n        \"opacity\",\n        \"transparent\",\n        \"side\",\n        \"depthWrite\",\n        \"depthTest\",\n      ];\n\n      // Extract Acceptable Props\n      const props = {};\n      materialPropsKeys.map(propName => {\n        if (otherProps[propName]) {\n          props[propName] = otherProps[propName];\n        }\n\n        return null;\n      });\n\n      return Object.keys(props).length > 0 ? props : undefined;\n    },\n    [otherProps]\n  );\n\n  // Environment Map\n  const _envMap = useMemo(\n    function updateEnvMap() {\n      if (view3DEnvMap) {\n        return envMap;\n      }\n\n      return null;\n    },\n    [view3DEnvMap, envMap]\n  );\n\n  // Loading Text\n  const loadingText = useMemo(\n    function updateLoadText() {\n      return fbxURL || \"No fbxURL\";\n    },\n    [fbxURL]\n  );\n\n  // Load FBX\n  useEffect(\n    function updateFBX() {\n      if (group) {\n        loadFBX({\n          group,\n          fbxPath,\n          fbxURL,\n          envMap: _envMap,\n          castShadow,\n          receiveShadow,\n          materialProps,\n        });\n      }\n    },\n    [group, fbxPath, fbxURL, _envMap, castShadow, receiveShadow, materialProps]\n  );\n\n  return (\n    <Group ref={group} {...otherProps}>\n      <Label text={loadingText} textColor=\"red\" />\n    </Group>\n  );\n};\n\nFBX.propTypes = exact({\n  fbxPath: PropTypes.string,\n  fbxURL: PropTypes.string,\n  ...GroupPropTypes,\n});\n\nconst FBXMemo = memo(FBX);\nFBXMemo.displayName = \"FBX\";\nexport default FBXMemo;\n","import React from \"react\";\n// import * as THREE from \"three\";\n// import { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader\";\nimport { View3D, Box, GLTF, Plane, DirectionalLight } from \"@standard/view\";\nimport FBX from \"./FBX\";\n\nconst View = () => {\n  // const loader = new FBXLoader();\n  // loader.load(\"fbx/Samba Dancing.fbx\", obj => {\n  //   const mixer = new THREE.AnimationMixer(obj);\n  //   const action = mixer.clipAction(obj.animation[0]);\n  //   action.play();\n  //   obj.traverse(child => {\n  //     if (child.isMesh) {\n  //       child.castShadow = true;\n  //       child.receiveShadow = true;\n  //     }\n  //   });\n\n  //   // scene.add(obj);\n  // });\n\n  return (\n    <View3D orbitControls backgroundColor=\"red\">\n      <DirectionalLight />\n      <Box\n        color=\"white\"\n        hoverColor=\"blue\"\n        onClick={() => console.log(\"clicked\")}\n        textureURL=\"gsball.png\"\n      />\n      <FBX fbxURL=\"fbx/Samba Dancing.fbx\" />\n      <GLTF gltfURL=\"gltf/flamingo.glb\" />\n    </View3D>\n  );\n};\n\nexport default View;\n","import React from \"react\";\nimport logo from \"./logo.svg\";\nimport \"bootswatch/dist/lux/bootstrap.min.css\";\nimport View from \"./components/View\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">PORYGON</header>\n      <View />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}