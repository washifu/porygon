{"version":3,"sources":["components/FBX.tsx","components/View.js","App.js","serviceWorker.js","index.js"],"names":["useEffect","React","useMemo","useRef","loadFBX","group","fbxPath","fbxURL","mixer","envMap","castShadow","receiveShadow","materialProps","actionIndex","fbxLoader","FBXLoader","setPath","load","fbx","current","children","map","child","remove","color","otherMaterialProps","updateAllMaterials","Array","isArray","object","constructor","name","material","set","Object","entries","propName","value","scene","THREE","animations","length","clipAction","play","traverse","mesh","isMesh","add","console","warn","FBXMemo","memo","view3DEnvMap","otherProps","useViewContext","keys","props","undefined","_envMap","loadingText","clock","useAnimationFrame","delta","getDelta","update","ref","text","textColor","displayName","View","orbitControls","backgroundEquirectangularTextureURL","camera","position","controls","enableZoom","intensity","gltfURL","App","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.f366487f.chunk.js","sourcesContent":["// FBX.tsx\nimport * as React from \"react\";\nimport * as THREE from \"three\";\nimport { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader\";\nimport PropTypes from \"prop-types\";\nimport exact from \"prop-types-exact\";\nimport {\n  Label,\n  Group,\n  GroupPropTypes,\n  useViewContext,\n  useAnimationFrame,\n} from \"@standard/view\";\n\nconst { useEffect, useMemo, useRef, memo } = React;\n\ninterface FBXProps {\n  fbxPath?: string;\n  fbxURL: string;\n  view3DEnvMap: boolean;\n  castShadow: boolean;\n  receiveShadow: boolean;\n}\n\nfunction updateAllMaterials(\n  color: string,\n  children: any,\n  materialProps: any\n): void {\n  if (children == null) {\n    return;\n  }\n\n  const _children = Array.isArray(children) ? children : [children];\n\n  _children.map(object => {\n    // Recurse into Groups\n    if (object.constructor.name === \"Group\" && object.children) {\n      updateAllMaterials(color, object.children, materialProps);\n    }\n\n    // @ts-ignore:TS2339 material does not exist on Object3D\n    if (object.material) {\n      if (color) {\n        // @ts-ignore:TS2339 material does not exist on Object3D\n        object.material.color.set(color);\n      }\n      Object.entries(materialProps).map(([propName, value]) => {\n        /* eslint-disable no-param-reassign */\n        // @ts-ignore:TS2339 material does not exist on Object3D\n        object.material[propName] = value;\n        /* eslint-enable no-param-reassign */\n        return null;\n      });\n    }\n\n    return null;\n  });\n}\n\ninterface LoadFBXProps {\n  group: React.MutableRefObject<any>;\n  fbxPath: string;\n  fbxURL: string;\n  mixer: React.MutableRefObject<any>;\n  envMap: THREE.Texture;\n  castShadow: boolean;\n  receiveShadow: boolean;\n  materialProps: any;\n  actionIndex?: number;\n}\n\nfunction loadFBX({\n  group,\n  fbxPath,\n  fbxURL,\n  mixer,\n  envMap,\n  castShadow,\n  receiveShadow,\n  materialProps,\n  actionIndex = 0,\n}: LoadFBXProps): void {\n  // No FBX\n  if (fbxURL == null) {\n    /* eslint-disable no-console */\n    console.warn(\"[FBX] No fbxURL\");\n    /* eslint-enable no-console */\n    return;\n  }\n\n  // FBX\n  const fbxLoader = new FBXLoader();\n  fbxLoader.setPath(fbxPath);\n  fbxLoader.load(fbxURL, (fbx: any) => {\n    if (group.current && fbx) {\n      // Remove Loading Label or Previous OBJ\n      if (group.current.children) {\n        group.current.children.map(child => group.current.remove(child));\n      }\n\n      // Material Props\n      if (materialProps) {\n        const { color, ...otherMaterialProps } = materialProps;\n        updateAllMaterials(color, fbx.scene.children, otherMaterialProps);\n      }\n\n      // Animation\n      mixer.current = new THREE.AnimationMixer(fbx);\n      if (fbx.animations?.length > 0) {\n        const action = mixer.current.clipAction(fbx.animations[actionIndex]);\n        action.play();\n      }\n\n      // Env Map + Shadows\n      fbx.traverse(mesh => {\n        /* eslint-disable no-param-reassign */\n        // @ts-ignore\n        if (mesh.isMesh) {\n          if (envMap) {\n            // @ts-ignore\n            mesh.material.envMap = envMap;\n          }\n          mesh.castShadow = castShadow;\n          mesh.receiveShadow = receiveShadow;\n        }\n        /* eslint-enable no-param-reassign */\n      });\n\n      // Add FBX\n      group.current.add(fbx);\n    }\n  });\n\n  return;\n}\n\nconst FBX: React.FunctionComponent<FBXProps> = function FBX({\n  fbxPath = \"\",\n  fbxURL,\n  view3DEnvMap = false,\n  castShadow = false,\n  receiveShadow = false,\n  ...otherProps\n}) {\n  const group = useRef();\n  const mixer = useRef<THREE.AnimationMixer>();\n  const { envMap } = useViewContext();\n\n  // Material Props\n  const materialProps = useMemo(\n    function updateMaterialProps() {\n      // No Material Props\n      if (!otherProps || Object.keys(otherProps).length === 0) {\n        return undefined;\n      }\n\n      // Acceptable Material Props\n      const materialPropsKeys = [\n        \"color\",\n        \"wireframe\",\n        \"opacity\",\n        \"transparent\",\n        \"side\",\n        \"depthWrite\",\n        \"depthTest\",\n      ];\n\n      // Extract Acceptable Props\n      const props = {};\n      materialPropsKeys.map(propName => {\n        if (otherProps[propName]) {\n          props[propName] = otherProps[propName];\n        }\n\n        return null;\n      });\n\n      return Object.keys(props).length > 0 ? props : undefined;\n    },\n    [otherProps]\n  );\n\n  // Environment Map\n  const _envMap = useMemo(\n    function updateEnvMap() {\n      if (view3DEnvMap) {\n        return envMap;\n      }\n\n      return null;\n    },\n    [view3DEnvMap, envMap]\n  );\n\n  // Loading Text\n  const loadingText = useMemo(\n    function updateLoadText() {\n      return fbxURL || \"No fbxURL\";\n    },\n    [fbxURL]\n  );\n\n  // Load FBX and Animation Mixer\n  useEffect(\n    function updateFBXandMixer() {\n      if (group) {\n        loadFBX({\n          group,\n          fbxPath,\n          fbxURL,\n          mixer,\n          envMap: _envMap,\n          castShadow,\n          receiveShadow,\n          materialProps,\n        });\n      }\n    },\n    [group, fbxPath, fbxURL, _envMap, castShadow, receiveShadow, materialProps]\n  );\n\n  // Animation Mixer Update\n  const clock = new THREE.Clock();\n  useAnimationFrame(function updateMixer() {\n    const delta = clock.getDelta();\n    mixer.current?.update(delta);\n  });\n\n  return (\n    <Group ref={group} {...otherProps}>\n      <Label text={loadingText} textColor=\"red\" />\n    </Group>\n  );\n};\n\nFBX.propTypes = exact({\n  fbxPath: PropTypes.string,\n  fbxURL: PropTypes.string,\n  ...GroupPropTypes,\n});\n\nconst FBXMemo = memo(FBX);\nFBXMemo.displayName = \"FBX\";\nexport default FBXMemo;\n","import React, { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport {\n  View3D,\n  GLTF,\n  Box,\n  OBJ,\n  DirectionalLight,\n  AmbientLight,\n  SpotLight,\n  Axis,\n  useViewContext,\n  useAnimationFrame,\n} from \"@standard/view\";\nimport FBX from \"./FBX\";\n\nconst View = () => {\n  return (\n    <View3D\n      orbitControls\n      backgroundEquirectangularTextureURL=\"backgrounds/palace_watermarked.jpg\"\n      camera={{ position: [0, 2, 10] }}\n      controls={{ enableZoom: false }}\n    >\n      <SpotLight intensity={0.7} color=\"cyan\" position={[0, 0, 10]} />\n      <SpotLight intensity={0.4} color=\"cyan\" position={[0, 0, -10]} />\n      <SpotLight intensity={0.7} color=\"snow\" position={[0, 0, 10]} />\n      <SpotLight intensity={0.4} color=\"sand\" position={[0, 0, -10]} />\n      <SpotLight intensity={0.6} color=\"tan\" position={[0, 0, -10]} />\n      <SpotLight intensity={0.3} color=\"tan\" position={[0, 0, 10]} />\n      <DirectionalLight intensity={0.3} position={[0, 1, 0]} />\n      <AmbientLight intensity={0.2} />\n      {/* <FBX\n        scale={[0.1, 0.1, 0.1]}\n        position={[0, -12, 0]}\n        rotation={[-Math.PI / 2, 0, 0]}\n        fbxURL=\"fbx/sophia.fbx\"\n      />\n      <FBX\n        scale={[0.1, 0.1, 0.1]}\n        position={[0, -10, 50]}\n        // rotation={[-Math.PI / 2, 0, 0]}\n        fbxURL=\"fbx/samba.fbx\"\n      /> */}\n      {/* <Axis /> */}\n      <Box />\n      <GLTF gltfURL=\"gltf/flamingo.glb\" />\n    </View3D>\n  );\n};\n\nexport default View;\n","import React from \"react\";\nimport \"bootswatch/dist/lux/bootstrap.min.css\";\nimport View from \"./components/View\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">PORYGON</header>\n      <View />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}